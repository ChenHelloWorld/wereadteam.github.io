<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="微信读书,iOS" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="WeRead团队博客">
<meta property="og:url" content="http://weread.qq.com/index.html">
<meta property="og:site_name" content="WeRead团队博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WeRead团队博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> WeRead团队博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">WeRead团队博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            歸檔
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/19/SQLite/" itemprop="url">
                  SQLite线程模式探讨
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-08-19T11:50:55+08:00" content="2016-08-19">
              2016-08-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分類於</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/zepo/" itemprop="url" rel="index"-->
                    <span itemprop="name">zepo</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/19/SQLite/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/19/SQLite/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>背景</h1>
<p>最近微信 iOS 团队发表了一篇文章<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=4#wechat_redirect" target="_blank" rel="external">《微信iOS SQLite源码优化实践》</a>，该文章介绍了微信 iOS 客户端对 SQLite 进行的源码层级的优化，以及其所取得的成果。优化点包括：</p>
<ol>
<li>多线程并发优化（Busy Retry 的优化）</li>
<li>I/O 性能优化（保留 WAL 文件大小，mmap 优化）</li>
<li>其他优化（禁用文件锁，禁用内存统计锁）</li>
</ol>
<p>其中，单是<strong>禁用内存统计锁</strong>这点优化，就取得了非常显著的效果，这里引用原文：</p>
<blockquote>
<p>该优化上线后，卡顿监控系统监测到</p>
<ul>
<li>DB写操作造成的卡顿下降超过80%</li>
<li>DB读操作造成的卡顿下降超过85%</li>
</ul>
</blockquote>
<p>&lt;!--more--&gt;</p>
<blockquote>
<p><img src="/./img/wechat_stutter.png" alt=""></p>
</blockquote>
<p>看到这结果，首先是满怀惊喜，仅仅是禁用 SQLite 的内存统计这一点，就能使 DB 的卡顿下降超过80%，如果再加上其他优化，那么 SQLite 的性能将实现一次突破！但冷静下来之后，也很快产生怀疑，<strong>SQLite 这么成熟的开源数据库，怎么会为了一个内存统计牺牲这么大的性能，要知道，性能是任何一个数据库都极力追求的目标</strong>。</p>
<p>所有的猜测都是没用的，实际测一下便知道孰是孰非。为了测试方便，使用自己的开源框架 GYDataCenter，每一行数据包括 NSInteger，double，BOOL，NSDate(double)，NSString 5列，测试机器为 iPhone 6s 64G，测试过程如下：</p>
<ol>
<li>打开 SQLite 内存统计，分别测试写入 10, 100, 1000，10000，100000 条数据所需时间；</li>
<li>关闭 SQLite 内存统计，分别测试写入 10, 100, 1000，10000，100000 条数据所需时间；</li>
<li>对比结果如下，横轴是数据量，纵轴是时间，单位秒；</li>
</ol>
<p><img src="/./img/memstatus_performance.png" alt=""></p>
<p>从结果我们可以看出，<strong>打开或关闭 SQLite 的内存统计，性能基本没差别</strong>，仅有的一点点差别都是在误差范围内的。我们又对读操作进行了同样的测试，结果依然没有差别。</p>
<p>问题出在于哪？究竟是哪个数据有问题？又或者是两个数据都没问题，只是我们打开的方式不对？于是，又重读了一遍微信的文章，发现该文章给出了这样的解释：</p>
<blockquote>
<p>多线程并发时，各线程很容易互相阻塞。
阻塞虽然也很短暂，但频繁地切换线程，却是个很影响性能的操作，尤其是单核设备。
因此，如果不需要内存统计的特性，可以通过sqlite3_config(SQLITE_CONFIG_MEMSTATUS, 0)进行关闭。</p>
</blockquote>
<p><strong>加锁和释放锁本身是有性能损耗，但这种损耗是很小的，基本上可以忽略，通常锁所带来的性能损耗正是在于等待其他线程释放锁的时间上</strong>。这正是两者的区别所在：</p>
<ol>
<li><strong>GYDataCenter 使用的是单线程单句柄的模式</strong>。对于同一个 db 的所有操作，都放到同一个队列同一个数据库句柄上，排队执行。并通过定时事务自动地把多个操作包在一起，批量地写入磁盘。</li>
<li><strong>微信 iOS 客户端采用的是多线程多句柄的模式</strong>。对于每一个 db，会开多个数据库句柄。对于同一个数据库句柄，同一时间只能在一个队列运行。多个句柄间可以做到读与读，读与写的并发。</li>
</ol>
<p>GYDataCenter 在关闭 SQLite 的内存统计后，性能没有得到提升，正是因为 GYDataCenter 使用的是单线程模式，不会有多线程间等待锁的问题。GYDataCenter 从设计上根本地避免了多线程间等待锁的问题。而反观微信的文章，大部分的优化都是在解决多线程间等待锁所引起的性能损耗问题，解决 Busy Retry 使<code>等待线程锁的造成的卡顿下降超过90%</code>，解决内存统计的锁使<code>卡顿下降超过 80%</code>。这似乎也说明了<strong>多线程模式带来了很严重的竞争锁的问题</strong>。并且，Busy Retry 的线程锁，内存统计的锁只是其中两种锁，可能还有其他各种各样的锁急需优化。</p>
<p>然而，单从这点就说单线程单句柄模式比多线程多句柄模式好是不正确的，多线程多句柄模式有它自己的优点，其中最明显的一点正是这种模式支持读与读，读与写的并发（WAL 模式下）。那么，我们就来具体分析一下，在移动客户端这个场景下，哪种模式可能更适用。</p>
<h1>多线程多句柄 vs 单线程单句柄</h1>
<h2>并发的需求</h2>
<p>要回答这个问题，首先我们要问，<strong>在移动客户端下，数据库的读与读，读与写的并发的需求有多强</strong>？</p>
<p>还是拿数据说话。在 iPhone 6s 上对微信读书 app 的主要场景进行了数据库并发性的统计。由于不同 app 不尽相同，不同机器性能也不一样，因此下面的统计数据只能做参考意义。</p>
<p><img src="/./img/concurrence.png" alt=""></p>
<p>在上面的结果中，对于<strong>n读0写</strong>跟<strong>n读1写</strong>的情况，多线程模式能起到优化作用。这两种情况分别占了 2% 跟 7%。我们进一步分析发现，出现这两种情况的场景，大多数是在网络请求回来时处理数据。</p>
<p>**分析：移动客户端 app 的运行，都是用户操作驱动的。用户在界面上进行一系列操作，从主线程发起请求，app 响应请求，处理数据，显示结果，一般来说这一系列动作是一条线串起来执行的，没有并发的需求。移动客户端出现的最多的并发情况，在于发起网络请求，和网络请求回来后的数据处理。然而，在网络请求回来的情况下，数据库执行最多的操作是存储返回的数据。对于这种情况，我们都知道，通过事务把多个写操作包在一起能极大地提升性能。**下面，我们分析一下两种方案在这种情况下的表现：</p>
<ol>
<li>多线程多句柄：如果把写操作放在一个事务中，在事务结束前，其他线程其他句柄的操作都会被卡住，返回 Busy Retry，造成空等待。</li>
<li>单线程单句柄：自动地把多个写操作包在一个事务中，由于所有操作都放到一个队列，其他的读写操作可以穿插其中，不会被卡住。</li>
</ol>
<p>当然，如果你对返回的数据的存储有原子性要求，即要求在存储期间不能有其他任何的读写操作，那么其他读写操作是一定会被卡住的，两种方案都是无法解决的。</p>
<h2>Cache 的管理</h2>
<p>我们都知道，cache 能很好地提升性能。如果采用单线程的方案，cache 的实现就比较简单了。由于所有操作都是在一个队列上排队操作，cache 的维护与查询也在一个队列上排队进行即可，cache 与 db 数据的一致性可以得到保证。</p>
<p>而如果在多线程多句柄方案上做 cache，可能会有以下两个难点：</p>
<ol>
<li>保证 cache 与 db 数据的一到性；</li>
<li>由于 cache 也是在多线程访问的，因此也需要加锁，也有可能引进竞争锁的性能问题；</li>
</ol>
<h1>结语</h1>
<p>通过上面的分析，我个人更偏向于使用单线程单句柄的模式。然而，世事无绝对，还是要具体情况具体分析。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/26/AndroidPatch/" itemprop="url">
                  Android Patch 方案与持续交付
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-07-26T19:44:33+08:00" content="2016-07-26">
              2016-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分類於</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/mason/" itemprop="url" rel="index"-->
                    <span itemprop="name">mason</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/26/AndroidPatch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/26/AndroidPatch/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android 不仅系统版本众多，机型众多，而且各个市场都各有各的政策和审核速度，每次发布一个版本对于开发同学来讲都是一种漫长的煎熬。相比于 iOS 两三天就能达到 80% 的覆盖速度而言，Android 应用版本升级至少需要两周才能达到 80% 的升级率，严重阻碍了版本迭代速度。也导致<strong>市场上 App 版本分散</strong>，处理 bug 和投诉等也越来越麻烦。</p>
<ul>
<li>修复的 bug 需要等待下个版本发布窗口才能发布？</li>
<li>已经 ready 的需求排队上线，需要等待其他 Feature Team 合入代码？</li>
<li>老版本升级速度慢？频繁上线版本提醒用户升级，影响用户体验？</li>
</ul>
<p>这几个问题是每个 App 开发同学都必然要面对的。那么有没有方法能在用户无感知的情况下<strong>加速 bug 处理和版本迭代速度</strong>？</p>
<p>在这方面 PC 端 Chrome 浏览器的 **<a href="https://www.chromium.org/developers/design-documents/software-updates-courgette" target="_blank" rel="external">patch 升级方案</a>**给我们了一个很好的借鉴：当 Chrome 有版本升级的时候会自动下载 patch 文件。下次启动后，Chrome 就已经是新版本。</p>
<p>&lt;!--more--&gt;</p>
<h2>他山之石，可以攻玉</h2>
<p>近一两年 Android 热补丁框架非常热门。从最初 360 动态下发 lua 脚本，到后来出现的<a href="http://blog.csdn.net/RichieZhu/article/details/50601368" target="_blank" rel="external">各种方案</a>，如雨后春笋般出现。早期的补丁框架偏向于以<strong>代码修复</strong>为主，主要分为两大类：native hook 方案和 Multidex 方案。</p>
<p>native hook 方案如阿里巴巴的 <a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a> 和 <a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a>。Multidex 方案如 <a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=16" target="_blank" rel="external">Qzone</a>。切入点都是替换掉将要执行的代码。基于 <a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=16" target="_blank" rel="external">Qzone</a> 方案的思路，出现了 <a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">nuwa</a> 这个比较完善的库，工具链比较完善。</p>
<p>类似 Chrome 的 <a href="https://www.chromium.org/developers/design-documents/software-updates-courgette" target="_blank" rel="external">patch 升级方案</a>足以满足<strong>加速 bug 处理和版本迭代速度</strong>的需求，给了我们很大的借鉴意义。在安卓系统上，可以通过 hotfix 的思路来达到这一目的：下发补丁文件，更新 App 版本</p>
<h2>站在巨人的肩膀上</h2>
<p>在今年 3 月份开始做技术选型的时候把上面的几种方案试了一轮。其中 <a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a> 甚至跟上了现网的一个发布版本，但是由于影响正向开发过程（只能修改方法、不能修改 field、不能新增类等问题）、库本身难于维护（需要依赖外部开源力量进行维护）以及发现的莫名其妙的 bug（导致我们 App 下发 patch 后白屏），所以即使跟上了发布版本也没有使用。<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">nuwa</a> 仅支持更新 Java 代码，不能更新资源和 so 文件，满足不了我们的需求。</p>
<p>没有好用的轮子，我们决定自己造一个，于是有了现在的 patch 方案。</p>
<h2>App 只是一个加载器</h2>
<p>既然做安卓 patch 方案，最好的结果就是能支持更新 App 所有的代码和资源。但是</p>
<ul>
<li><code>Application</code> 类是 App 启动之初就被安卓系统加载起来，所以<strong>至少 <code>Application</code> 类和它启动依赖的其他业务类</strong>是不能被更新的？</li>
<li>修复 bug 或者版本迭代过程中难免会遇到需要修改资源文件的情况。资源文件能更新吗？</li>
<li>native 实现的 so 文件如何更新？</li>
</ul>
<p>针对上面三个问题，** 我们的设计是把 App 仅仅当做一个加载器**。系统启动 App 之后，加载器决定将要运行的代码和资源的位置。当有新功能或者 bugfix 需要推送给用户，替换加载器内容即可。</p>
<p><img src="/./img/androidPatch1.png" alt=""></p>
<h2>支持更新全部代码</h2>
<p>上面提到 <code>Application</code> 由于启动就被加载而不能被更新的问题，我们<strong>代理了真实 Application 类的创建过程</strong>。通过代理 <code>Application</code>，控制 <code>Application</code> <strong>从新 dex 文件中加载</strong>。假设真实的 <code>Application</code> 类是 <code>MyApplication</code>。我们在编译期间自动修改 <code>AndroidManifest.xml</code> 文件，把 <code>MyApplication</code> 替换为 <code>MoaiApplication</code>（是 App 的入口 <code>Application</code>）。App 启动后由 <code>MoaiApplication</code> 加载完相应的文件（dex/资源文件/so 文件）后，再将控制权交回给 <code>MyApplication</code>。</p>
<h4>代理生命周期</h4>
<p>将控制权交回给 <code>MyApplication</code>，我们最初是代理 <code>MyApplication</code> 的生命周期。具体做法是，<code>MoaiApplication</code> 决定加载哪里的业务代码、资源文件以及 so 文件之后依然负责接收 App 的全部生命周期，然后把生命周期代理给 <code>MyApplication</code>，简单例子如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyApplication delegate;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">  delegate = MyApplication.class.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate();</span><br><span class="line">  delegate.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有比较多生命周期函数上面代码就没一一列举。</p>
<p>从上面代码容易想到代理方案的缺点：<strong>必须要完整代理所有生命周期接口</strong>。否则 <code>MyApplication</code> 会由于生命周期<strong>不完整</strong>而出现奇怪的 bug。比如我们最初版本在测试过程中就出现了没有代理 <code>registerActivityLifecycleCallbacks</code> 函数而导致拿不到 <code>Activity</code> 生命周期 <code>onActivityCreated</code>/<code>onActivityDestroyed</code> 等回调。</p>
<h4>反射 <code>Application</code></h4>
<p>踩到生命周期回调不完整的坑之后，我们开始考虑能不能把 App 运行期间 <code>Application</code> 的引用<strong>全部</strong>替换成 <code>MyApplication</code> ？这样就无需 <code>MoaiApplication</code> 把生命周期代理给 <code>MyApplication</code>，而是由 <code>MyApplication</code> 直接接收系统回调。安卓系统 <code>ContextWrapper</code> 的实现是包装了一层真正的 <code>mBase</code> 上下文，App 真正使用到的就是这个 <code>mBase</code>。通过反射 <code>mBase</code> 以及其中字段对 <code>Application</code> 的引用，『彻底』解决了需要手写代理 <code>Application</code> 全部生命周期的方法。</p>
<h4>dex分包</h4>
<p><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=16" target="_blank" rel="external">Qzone</a> 方案下发的 patch 文件是变更过的 Java 类组成的 patch.dex，在 dalvik 和 ART 虚拟机下分别需要解决 <code>Class ref in pre-verified class resolved to unexpected implementation</code> 和内存地址错乱问题。这些问题根源在于改变了类原本所属的 dex 文件。既然改变类所在的 dex 会导致各种各样的问题，那直接替换掉整个 dex 不就好了？在调研 <a href="http://zeroturnaround.com/software/jrebel-for-android/" target="_blank" rel="external">JRebal for Android</a> 和 <a href="https://github.com/nuptboyzhb/AndroidInstantRun" target="_blank" rel="external">Instant Run</a> 的时候也发现了他们有类似的做法。</p>
<p>我们把 App 的 dex 分成两部分：</p>
<ul>
<li>patch 库的 dex 文件 -&gt; classes.dex</li>
<li>其他业务代码的 dex 文件 -&gt; classes[N].dex</li>
</ul>
<p>其中 classes.dex 中仅包含了 patch 库的全部代码，并不包含任何其他业务代码。</p>
<p>假设 apk 中包含三个文件：classes.dex、classes2.dex、classes3.dex。classes.dex 充当的角色就是<strong>加载器</strong>，负责启动 App 并且加载后面的两个 dex。这样做的目的是，App 启动需要用到的所有类都集中在 classes.dex 中，所有业务代码的类都集中在 classes[N].dex 中。如果某次下发 patch 代码把 classes2.dex 变更为 classes2-1.dex，那么由加载器加载 classes2-1.dex 和  classes3.dex 即可实现更新包含 <code>MyApplication</code> 类在内的所有代码。</p>
<h2>怎么加载更新后的代码？</h2>
<p>如果 dex 文件有更新，加载器会选择加载更新后的文件。我们最初采用了 Google 官方的 Multidex 方案，扩展 <code>DexPathList</code> 的 <code>dexElements</code> 字段。</p>
<h4>Multidex 方案存在问题</h4>
<p>Multidex 方案上线后发现某些机型（比如三星s6 5.0.2 ROM）并不能加载扩展进去的 dex 中的代码。debug 阶段却能顺利加载（debugger 拖慢代码执行速度）。目前的猜测是某些厂商在 5.x 以上版本改动 ROM 导致 App 启动逻辑有<strong>多线程</strong>并发执行。</p>
<p>最终我们弃用了 Multidex 方案，转而 Hack 系统 <code>ClassLoader</code>。</p>
<h4><code>ClassLoader</code> Hack 方案</h4>
<p><strong>所有线程使用的是同一个 ClassLoader 对象</strong>。所以一旦 Hack 了这个对象，所有线程都开始使用 Hack 过的对象，从而能够解决多线程导致加载不到扩展的 dex 文件中代码的问题。</p>
<p>安卓系统加载代码的 <code>ClassLoader</code> 是 <code>PathClassLoader</code> 和 <code>BootClassLoader</code>。我们最初设计的方案是在 <code>PathClassLoader</code> 和 <code>BootClassLoader</code> 之间插入一个 <code>BaseDexClassLoader</code>，让所有业务代码都在这个插入的 <code>BaseDexClassLoader</code> 中加载。但是这样的设计存在<strong>缺陷</strong>：业务代码的 <code>ClassLoader</code> 会变成 <code>BaseDexClassLoader</code>，如果业务代码依赖了 patch 库的代码（在 classes.dex 中），会出现 <code>ClassNotFoundException</code>。</p>
<p>在这方面 <a href="https://github.com/nuptboyzhb/AndroidInstantRun" target="_blank" rel="external">Instant Run</a> 的设计很精巧。它让 <code>PathClassLoader</code> 插入的父 loader （<code>IncrementalClassLoader</code>）包装了  <code>DelegateClassLoader</code>，并且把 <code>DelegateClassLoader</code> 的父 loader 设置为 <code>PathClassLoader</code>，使得类加载的路径变成：</p>
<p><img src="/./img/androidPatch2.png" alt=""></p>
<p>在 <code>DelegateClassLoader</code> 加载业务代码的时候（业务代码在 classesN.dex 中），流程会沿着标记的顺序最终第 5 步成功加载到业务代码。业务代码如果依赖 patch 库的代码，会在 <code>PathClassLoader</code> 加载。这样所有代码都可以被加载到。</p>
<h2>怎么更新资源？</h2>
<p>单纯更新 Java 代码的 patch 框架，实用性会受到很大的局限。开发同学需要<strong>仔细</strong>验证提交内容，确保提交中不包含资源文件的变更以及 native so 的改动，会导致本就复杂的开发流程变得更加繁琐。所以我们在支持更新 Java 代码的基础之上，也支持更新资源和 native so 文件。</p>
<p>App 加载资源是依赖 <code>Context#getResources</code> 函数返回的 <code>Resources</code> 对象。<code>Resources</code> 内部包装了 <code>AssetManager</code>，最终由  <code>AssetManager</code> 从 apk 文件中加载资源。所以我们反射了替换系统默认的 <code>Resources</code>，让 <code>AssetManager</code> 从我们更新后的 apk 中加载资源。现阶段的实现支持比如 string/anim/drawable/color/layout 等资源文件的变更。由于 Android 系统在安装 apk 时候已经把 <code>AndroidManifest.xml</code> 文件解析并写入到系统中，目前还不支持修改四大组件，比如增加 <code>Activity</code>。后续会继续研究如何做到无缝修改四大组件。</p>
<h2>怎么更新 so 文件？</h2>
<p>在 Android 项目中使用 native 函数前需要先调用 <code>System.loadLibrary(libName)</code>。</p>
<p>当 lib 文件需要更新或者有 bug 时候怎么办？首先想到的是在代码中把加载 so 文件的代码改成<code>System.load(libFilePath)</code>，让系统加载自己指定的 <code>libFilePath</code> 文件。然而这样的改动需要</p>
<ul>
<li>在源代码中修改或者使用工具在编译期把 <code>loadLibrary</code> 接口改为 <code>load</code></li>
<li>patch 库把 so 文件从 patch 文件中复制到特定目录</li>
</ul>
<p>这样在运行期才有可能加载更新后的 so 文件。</p>
<p>通过分析系统加载 so 文件的方式后，我们使用了更简单的处理方法。查找 lib 文件是通过调用 <code>PathClassLoader</code> 的 <code>findLibrary</code>，最终调用到 <code>DexPathList</code> 的 <code>findLibrary</code>。<code>DexPathList</code> 会在自己维护的列表目录中查找对应的 lib 文件是否存在。所以我们在发现 patch 文件中有 so 文件变更的时候，会在 <code>PathClassLoader</code> 的 <code>nativeLibraryDirectories</code>（Android6.0以下）或者<code>nativeLibraryPathElements</code> （Android 6.0及以上）的最前面<strong>插入自定义的lib文件目录</strong>。这样 <code>ClassLoader</code> 在 <code>findLibrary</code> 的时候会先在自定义的 lib 目录中查找，优先加载变更过的 so 文件。</p>
<h2>patch 包的生成与应用</h2>
<p>回到我们最初的目标：<strong>patch 不应该影响正向开发流程</strong>。我们生成 patch 文件是针对 apk 进行的，开发同学无需关心此次发布是 patch 版本还是正常版本，只需要正常开发并且打包要发布的 apk 即可，不会对正向开发流程产生任何影响。</p>
<p>我们提供 python 脚本生成两个 apk 的：对比两个 apk 中的所有文件，找出有变更的文件进行 diff，把 diff 结果写入 patch 文件。线上用户下载 patch 文件到本地之后，启动一条新的进程使用 <code>context.getApplicationInfo().sourceDir</code> 路径的 apk 与 patch 文件合并，得到新的 apk（包含资源文件，不包含 dex 文件）以及 dex 文件、native so 文件，并在这条进程中提前做 dex 优化（dex2oat/dexopt）。针对 dex 优化过程太慢的问题（优化过程慢会导致进程可能会系统kill，降低 patch 成功率）我们并发了 dex 优化过程，使 patch 过程耗时相对减小。新 apk、dex文件、so 文件就可以在<strong>下次启动</strong> App 的时候由加载器加载。</p>
<h2>优势和不足</h2>
<p>正所谓没有完美的架构，只有适合自己的架构。当前的开源方案并不能满足我们加速 bug处理和版本迭代速度的需求，于是有了站在巨人肩膀上的思考和我们现在的 patch 方案。我们目前的优势：</p>
<ul>
<li>全面支持 patch Java 代码、资源文件 和 native so 文件。版本只需要正常滚动，开发同学无需关心是发布 patch 版本还是正常版本</li>
<li>使用相对简单（<strong>减少接入成本</strong>也是我们的最初思考点之一），只需要在 <code>build.gradle</code> 中加入三行代码即可，无需更多配置。</li>
</ul>
<p>从我们团队发布的多个 patch 版本来看，下发的 diff 结果文件稍大。大文件下载过程可能出现的错误也会间接影响到 patch 铺开的速度，所以我们也在尝试更好的 diff 方案。Chrome 最初升级方案也是 bsdiff，而后慢慢演变出 <a href="https://www.chromium.org/developers/design-documents/software-updates-courgette" target="_blank" rel="external">Courgette</a> 算法。</p>
<h2>演进与思考</h2>
<p>我们对于补丁框架的定义不仅仅是『修复bug』就足够，除此之外，如何快速接入，如何做到不影响现有流程，这对于很多应用来说至关重要。在此之上，搞清楚框架的定位，适当舍弃一些不重要方面的时候，快速迭代，在迭代中持续优化，事情往往比想象的更加简单。</p>
<p><a href="http://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/" target="_blank" rel="external">持续交付</a>一直都是快速迭代思想的一种践行方式，对于 App 开发而言，如果我们通过构造补丁框架这样一个渠道，可以通过自动化系统把补丁快速地把新功能推送给用户，那这个事情的意义就不仅仅是『修复 bug』这么简单。减少线上 crash 率和加速版本迭代、让新功能尽早与用户见面，从而可以在更短的时间内不断收集用户反馈信息对产品进行打磨。</p>
<p>目前我们已经在微信读书线上三个版本开始试行了用补丁代替版本发布或者加速老版本升级的做法，期待将来能通过这个渠道，为安卓开发同学们做到无感知的持续交付过程 。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/20/MLeaksFinder2/" itemprop="url">
                  MLeaksFinder 新特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-07-20T14:35:26+08:00" content="2016-07-20">
              2016-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分類於</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/zepo/" itemprop="url" rel="index"-->
                    <span itemprop="name">zepo</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/20/MLeaksFinder2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/20/MLeaksFinder2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="external">MLeaksFinder</a> 是 iOS 平台的自动内存泄漏检测工具，引进 MLeaksFinder 后，就可以在日常的开发，调试业务逻辑的过程中自动地发现并警告内存泄漏。开发者无需打开 instrument 等工具，也无需为了找内存泄漏而去跑额外的流程。并且，由于开发者是在修改代码之后一跑业务逻辑就能发现内存泄漏的，这使得开发者能很快地意识到是哪里的代码写得问题。这种及时的内存泄漏的发现在很大的程度上降低了修复内存泄漏的成本。</p>
<p>MLeaksFinder 0.1 开源已经有一段时间，关于 MLeaksFinder 的基本原理，可以参考这篇<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="external">文章</a>。在 MLeaksFinder 开源之后，收到的最多的反馈是：MLeaksFinder 帮忙发现了内存泄漏，但是要去修复这些内存泄漏，找到造成问题的代码很难，特别是对于历史遗留的内存泄漏。</p>
<p>现在，MLeaksFinder 0.2 来了。如果说 0.1 版本旨在帮助开发者发现内存泄漏，那么 0.2 版本的新特性，正是旨在帮助开发者更好地解决内存泄漏。MLeaksFinder 0.2 包括以下几个新特性：</p>
<ul>
<li>assert 改为 alert</li>
<li>追踪对象的生命周期</li>
<li>查找循环引用链</li>
</ul>
<p>下面，我们来逐一看一下这几个特性。</p>
<p>&lt;!--more--&gt;</p>
<h1>assert 改为 alert</h1>
<p>在 MLeaksFiner 0.1 版本，当 MLeaksFinder 发现内存泄漏时，会直接中 assert 并打出内存泄漏的信息。Assert 能迫使开发者及时地去修复内存泄漏，并且，如果只是打日志，内存泄漏的日志很可能会被淹没在众多的日志中。这种 assert 的方法在我们实际的项目取得了不错的效果。</p>
<p>然而，assert 确实也有不好的一面。当开发者在调试业务逻辑的过程中，如果由于内存泄漏中 assert 而使得整个程序挂掉了，那么开发者的思维会因此被打断，并不得不在修复完内存泄漏之后，从头开始调试业务逻辑。有时候开发者更希望的是连贯地调完整个业务逻辑之后，再回过头来修复内存泄漏。</p>
<p>因此，MLeaksFinder 0.2 把 assert 改成了 alert。当发现内存泄漏之后，开发者可以把 alert 框关掉，并继续调试业务逻辑。而且，把 assert 改成 alert 之后，也使得进一步分析内存成为可能，为下面两个新特性垫定基础。</p>
<h1>追踪对象的生命周期</h1>
<p>当发现可能的内存泄漏对象并给出 alert 之后，MLeaksFinder 会进一步地追踪该对象的生命周期，并在该对象释放时给出 <code>Object Deallocated</code> 的 alert。</p>
<p>为什么认为一个对象内存泄漏之后，还要进一步去追踪该对象后续会不会释放呢？MLeaksFinder 的基本原理是这样的，当一个 ViewController 被 pop 或 dismiss 之后，我们认为该 ViewController，包括它上面的子 ViewController，以及它的 View，View 的 subView 等等，都很快会被释放，如果某个 View 或者 ViewController 没释放，我们就认为该对象泄漏了。然而，这样的判断内存泄漏的方法存在两个可能的“误判”：</p>
<p><strong>1) 单例或者被 cache 起来复用的 View 或 ViewController</strong></p>
<p>对于这样的 View 或 ViewController，在被 pop 或 dismiss 之后是不会被释放的。然而，由于 View 相关的对象一般都占用了较多了内存，这样的设计通常来说不是好的设计。如果开发者由于性能问题等原因而不得不这样设计的时候，开发者可以在报泄漏的类里重载 <code>- (BOOL)willDealloc</code> 方法，直接 <code>return NO;</code> 以消除内存泄漏的警告，这个消除内存泄漏警告的方法与 MLeaksFinder 0.1 版本一致。</p>
<p><strong>2) 释放不及时的 View 或 ViewController</strong></p>
<p>例如，发起网络请求的时候，在网络请求回调的 block 里强引用 ViewController，以便在网络请求回来的时候刷新界面。在网络请求比较慢的情况下，这种做法存在两个问题：</p>
<ul>
<li>ViewController 被 pop 之后，由于被 block 强引用导致释放不及时</li>
<li>ViewController 被 pop 之后，如果网络请求回来了，不应该继续做刷新界面的事，浪费 CPU</li>
</ul>
<p>所以，对于这种情况，我们应该在 block 里弱引用 ViewController，而不是强引用。</p>
<p>下面我们来看如何利用对象的生命周期来分析内存的真正使用情况，分三种情况：</p>
<p><strong>1) 单例或者被 cache 起来复用</strong></p>
<p>如下面所示，在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，即不报 Object Deallocated，也不报 Memory Leak。这种情况下我们可以确定该对象被设计成单例或者 cache 起来了。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    pop             push           pop           push          pop&#10;----------&#62; Leak ----------&#62; | ----------&#62; | ----------&#62; | ----------&#62;</span><br></pre></td></tr></table></figure></p>
<p><strong>2) 释放不及时</strong></p>
<p>如下面所示，在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    pop             push                 pop             push                 pop&#10;----------&#62; Leak ----------&#62; Dealloc ----------&#62; Leak ----------&#62; Dealloc ----------&#62; Leak</span><br></pre></td></tr></table></figure></p>
<p><strong>3) 真正的内存泄漏</strong></p>
<p>如下面所示，在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，不报 Object Deallocated，但每次 pop 之后又报 Memory Leak。这种情况下每回进入并退出一个页面后，就报有新的内存泄漏，同时被报泄漏的对象又从来没有释放过，可以确定是真正的内存泄漏。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    pop             push           pop             push           pop&#10;----------&#62; Leak ----------&#62; | ----------&#62; Leak ----------&#62; | ----------&#62; Leak</span><br></pre></td></tr></table></figure></p>
<h1>查找循环引用链</h1>
<p>Facebook 在前阵子开源了一个循环引用检测工具 <a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="external">FBRetainCycleDetector</a>。当传入内存中的任意一个 OC 对象，FBRetainCycleDetector 会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。</p>
<p>我们知道，很多循环引用是 block 的使用不当造成的。而 FBRetainCycleDetector 最大的技术亮点，正在于如何找出一个 block 的所有强引用对象。对于这个感兴趣的，可以看 facebook 的这篇<a href="https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/" target="_blank" rel="external">文章</a>。</p>
<p>然而，FBRetainCycleDetector 的使用存在两个问题：</p>
<ul>
<li>需要找到候选的检测对象</li>
<li>检测循环引用比较耗时</li>
</ul>
<p>正是由于这两个问题，FBRetainCycleDetector 通常是结合其它工具一起使用，通过其它工具先找出候选的检测对象，然后进行有选择的检测。当 MLeaksFinder 与 FBRetainCycleDetector 结合使用时，正好能达到很好的效果。我们先通过 MLeaksFinder 找到内存泄漏的对象，然后再过 FBRetainCycleDetector 检测该对象有没有循环引用即可。</p>
<p>循环引用的输出信息如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#10;    &#34;-&#62; MyTableViewCell &#34;,&#10;    &#34;-&#62; _callback -&#62; __NSMallocBlock__ &#34;&#10;)</span><br></pre></td></tr></table></figure></p>
<p>上面的信息表示，<code>MyTableViewCell</code> 有一个强引用的成员变量 <code>_callback</code>，该变量的类型是 <code>__NSMallocBlock__</code>，在 <code>_callback</code> 里，又强引用了 <code>MyTableViewCell</code> 造成循环引用。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/Aspects/" itemprop="url">
                  面向切面编程之 Aspects 源码解析及应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-06-30T10:42:03+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分類於</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/zach/" itemprop="url" rel="index"-->
                    <span itemprop="name">zach</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/30/Aspects/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/30/Aspects/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>1. 背景</h1>
<p>最近在做项目的打点统计的时候，发现业务逻辑和打点逻辑经常耦合在一起，这样一方面影响了正常的业务逻辑，同时也很容易搞乱打点逻辑，而且要查看打点情况的时候也很分散，因此想着如何将两者解耦，并将打点逻辑集中起来。其实在 web 编程时候，这种场景很早就有了很成熟的方案，也就是所谓的 aop 编程(面向切面编程)，其原理也就是在不更改正常的业务处理流程的前提下，通过生成一个动态代理类，从而实现对目标对象嵌入附加的操作。</p>
<p>在 iOS 中，要想实现相似的效果也很简单，利用 OC 的动态性，通过 swizzling method 改变目标函数的 selector 所指向的实现，然后在新的实现中实现附加的操作，完成之后再回到原来的处理逻辑。想明白这些之后，我就打算动手实现，当然并没有重复造轮子，我在 github 发现了一个基于 swizzling method 的开源框架 <a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a> 。这个库的代码量比较小，总共就一个类文件，使用起来也比较方便，比如你想统计某个  controller 的 viewwillappear 的调用次数，你只需要引入 Aspect.h 头文件，然后在合适的地方初始化如下代码即可。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addKvLogAspect &#123;&#10;    [self wr_Aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^&#123;&#10;        KVLog_ReviewTimeline(ReviewTimeline_Open_Tab);&#10;    &#125;error:NULL];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这篇文章主要是介绍 Aspects 源码以及其思路，以及我在实际应用中遇到的一些问题。对 swizzling method 不了解的同学可以先去网上了解一下，下面的内容是基于大家对 swizzling method 有一定的了解的基础上的。</p>
<p>&lt;!--more--&gt;</p>
<h1>2. 基本原理</h1>
<p>我们知道 OC 是动态语言，我们执行一个函数的时候，其实是在发一条消息：<code>[receiver message]</code>，这个过程就是根据 message 生成 selector，然后根据 selector 寻找指向函数具体实现的指针 IMP，然后找到真正的函数执行逻辑。这种处理流程给我们提供了动态性的可能，试想一下，如果在运行时，动态的改变了 selector 和 IMP 的对应关系，那么就能使得原来的<code>[receiver message]</code>进入到新的函数实现了。</p>
<p>那么具体怎么实现这样的动态替换了?</p>
<p>直观的一种方案是提供一个统一入口，如 commonImp ,将所有需要 hook 的函数都指向这个函数，然后在这里，提取相关信息进行转发，<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3#1%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86" target="_blank" rel="external">JSPatch 实现原理详解</a>对此方案的可行性有进行分析，对于64位机器可能会有点问题。另外一个方法就是利用 oc 自己的消息转发机制进行转发，Aspects 的大体思路，基本上是顺着这个来的。为了更好的解释这个过程，我们先来看一下消息具体是怎么找到对应的 imp 的，见下图（此图并非原创）。</p>
<p><img src="http://img.blog.csdn.net/20160629125258569" alt="流程图"></p>
<p>从上面我们可以发现，在发消息的时候，如果 selector 有对应的 IMP ,则直接执行，如果没有，oc 给我们提供了几个可供补救的机会，依次有 <code>resolveInstanceMethod</code> 、<code>forwardingTargetForSelector</code>、<code>forwardInvocation</code>。Aspects 之所以选择在 <code>forwardInvocation</code> 这里处理是因为，这几个阶段特性都不太一样：<code>resolvedInstanceMethod</code> 适合给类/对象动态添加一个相应的实现，<code>forwardingTargetForSelector</code> 适合将消息转发给其他对象处理,相对而言，<code>forwardInvocation</code> 是里面最灵活，最能符合需求的。因此 Aspects 的方案就是，对于待 hook 的 selector，将其指向 <code>objc_msgForward</code> / <code>_objc_msgForward_stret</code> ,同时生成一个新的 <code>aliasSelector</code> 指向原来的 IMP，并且 hook 住 <code>forwardInvocation</code> 函数，使他指向自己的实现。按照上面的思路，当被 hook 的 selector 被执行的时候，首先根据 selector 找到了 <code>objc_msgForward</code> / <code>_objc_msgForward_stret</code> ,而这个会触发消息转发，从而进入 <code>forwardInvocation</code>。同时由于 <code>forwardInvocation</code> 的指向也被修改了，因此会转入新的 <code>forwardInvocation</code> 函数，在里面执行需要嵌入的附加代码，完成之后，再转回原来的 IMP。</p>
<h1>3. 源码分析</h1>
<h2>3.1 数据结构</h2>
<p>介绍完大致思路之后，下面将从代码层来来具体分析。从头文件中可以看到使用aspects有两种使用方式：1）类方法 2）实例方法</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (id&#60;AspectToken&#62;)aspect_hookSelector:(SEL)selector&#10;                           withOptions:(AspectOptions)options&#10;                            usingBlock:(id)block&#10;                                 error:(NSError **)error;&#10;&#10;/// Adds a block of code before/instead/after the current `selector` for a specific instance.&#10;- (id&#60;AspectToken&#62;)aspect_hookSelector:(SEL)selector&#10;                           withOptions:(AspectOptions)options&#10;                            usingBlock:(id)block&#10;                                 error:(NSError **)error;</span><br></pre></td></tr></table></figure></p>
<p>两者的主要原理基本差不多，这里不做一一介绍，只是以实例方法为例进行说明。在介绍之前，先介绍里面几个重要的数据结构：</p>
<h3>AspectOptions</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;&#10;    AspectPositionAfter   = 0,            /// Called after the original implementation (default)&#10;    AspectPositionInstead = 1,            /// Will replace the original implementation.&#10;    AspectPositionBefore  = 2,            /// Called before the original implementation.&#10;    AspectOptionAutomaticRemoval = 1 &#60;&#60; 3 /// Will remove the hook after the first execution.&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里表示了 block 执行的时机，也就是额外操作的执行时机，在我的应用场景中就是打点逻辑的执行时机，它可以在原始函数执行之前，也可以是执行之后，甚至可以完全替换掉原来的逻辑。</p>
<h3>AspectsContainer</h3>
<p>一个对象或者类的所有的 Aspects 整体情况
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Tracks all aspects for an object/class.&#10;@interface AspectsContainer : NSObject&#10;- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;&#10;- (BOOL)removeAspect:(id)aspect;&#10;- (BOOL)hasAspects;&#10;@property (atomic, copy) NSArray *beforeAspects;&#10;@property (atomic, copy) NSArray *insteadAspects;&#10;@property (atomic, copy) NSArray *afterAspects;&#10;@end</span><br></pre></td></tr></table></figure></p>
<h3>AspectIdentifier</h3>
<p>一个 Aspect 的具体内容</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectIdentifier : NSObject&#10;+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;&#10;- (BOOL)invokeWithInfo:(id&#60;AspectInfo&#62;)info;&#10;@property (nonatomic, assign) SEL selector;&#10;@property (nonatomic, strong) id block;&#10;@property (nonatomic, strong) NSMethodSignature *blockSignature;&#10;@property (nonatomic, weak) id object;&#10;@property (nonatomic, assign) AspectOptions options;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>这里主要包含了单个的 aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等</p>
<h3>AspectInfo</h3>
<p>一个 Aspect 执行环境，主要是 NSInvocation 信息。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &#60;AspctInfo&#62;&#10;- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;&#10;@property (nonatomic, unsafe_unretained, readonly) id instance;&#10;@property (nonatomic, strong, readonly) NSArray *arguments;&#10;@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;&#10;@end</span><br></pre></td></tr></table></figure></p>
<h2>3.2 代码流程</h2>
<p>有了上面的了解，我们就能更好的分析整个 apsects 的执行流程。添加一个 aspect 的关键流程如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160629130456935" alt="这里写图片描述">
从代码来看，要想使用 aspects ，首先要添加一个 aspect ，可以通过上面介绍的类/实例方法。关键代码实现如下:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123;&#10;    ...&#10;    __block AspectIdentifier *identifier = nil;&#10;    aspect_performLocked(^&#123;&#10;        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;//1&#21028;&#26029;&#33021;&#21542;hook&#10;            ...//2 &#35760;&#24405;&#25968;&#25454;&#32467;&#26500;&#10;            aspect_prepareClassAndHookSelector(self, selector, error);//3 swizzling&#10;        &#125;&#10;    &#125;);&#10;    return identifier;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个过程基本和上面的流程图一致，这里重点介绍几个关键部分。</p>
<h3>3.2.1 判断能否被 hook</h3>
<p>对于对象实例而言，这里主要是根据黑名单，比如 retain forwardInvocation 等这些方法在外部是不能被 hook ,(对于类对象还要确保同一个类继承关系层级中，只能被 hook 一次，因此这里需要判断子类，父类有没有被 hook，之所以做这样的实现，主要是为了避免出现死循环的出现，这里有相关的讨论)。如果能够 hook，则继续下面的步骤。</p>
<h3>3.2.2 swizzling method</h3>
<p>这是真正的核心逻辑，swizzling method 主要有两部分，一个是对对象的 forwardInvocation 进行 swizzling,另一个是对传入的 selector 进行 swizzling.</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;&#10;    Class klass = aspect_hookClass(self, error); //1  swizzling forwardInvocation&#10;    Method targetMethod = class_getInstanceMethod(klass, selector);&#10;    IMP targetMethodIMP = method_getImplementation(targetMethod);&#10;    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;//2  swizzling method&#10;       ...//&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3>3.2.2.1 swizzling forwardInvocation:</h3>
<p>aspect_hookClass 函数主要 swizzling 类/对象的 forwardInvocation 函数，aspects 的真正的处理逻辑都是在 forwradInvocation 函数里面进行的。对于对象实例而言，源代码中并没有直接 swizzling 对象的 forwardInvocation 方法，而是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的 forwardInvocation 方法(这里具体方法就是调用了 object_setClass(self, subclass) ,将当前对象 isa 指针指向了 subclass ,同时修改了 subclass 以及其 subclass metaclass 的 class 方法,使他返回当前对象的 class。,这个地方特别绕，它的原理有点类似 kvo 的实现，它想要实现的效果就是，将当前对象变成一个 subclass 的实例，同时对于外部使用者而言，又能把它继续当成原对象在使用，而且所有的 swizzling 操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在 remove aspects 的时候，如果发现当前对象的 aspect 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 swizzling ,同时也不会影响到其他该类的不同对象)。对于每一个对象而言，这样的动态对象只会生成一次，这里 aspect_swizzlingForwardInvocation 将使得 forwardInvocation 方法指向 aspects 自己的实现逻辑 ,具体代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;&#10;     ...&#10;     //&#29983;&#25104;&#21160;&#24577;&#23376;&#31867;&#65292;&#24182;swizzling forwardInvocation&#26041;&#27861;&#10;     subclass = objc_allocateClassPair(baseClass, subclassName, 0); &#10;     aspect_swizzleForwardInvocation(subclass);//swizzling forwardinvation&#26041;&#27861;&#10;&#10;     objc_registerClassPair(subclass);&#10;      ...&#10;     object_setClass(self, subclass);//&#23558;&#24403;&#21069;self&#35774;&#32622;&#20026;&#23376;&#31867;&#65292;&#36825;&#37324;&#20854;&#23454;&#21482;&#26159;&#26356;&#25913;&#20102;self&#30340;isa&#25351;&#38024;&#32780;&#24050;&#10;     return subclass;&#10;&#125;&#10;...&#10;static void aspect_swizzleForwardInvocation(Class klass) &#123;&#10;     ...&#10;    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:),     (IMP)__ASPECTS_ARE_BEING_CALLED__, &#34;v@:@&#34;);&#10;    if (originalImplementation) &#123;&#10;         class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName),        originalImplementation, &#34;v@:@&#34;)&#10;      &#125;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于子类本身并没有实现 forwardInvocation ，隐藏返回的 originalImplementation 将为空值，所以也不会生成 NSSelectorFromString(AspectsForwardInvocationSelectorName) 。</p>
<h3>3.2.2.2 swizzling selector</h3>
<p>当 forwradInvocation 被 hook 之后，接下来，将对传入的 selector 进行 hook ，这里的做法是，将 selector 指向了转发 IMP ，同时生成一个 aliasSelector ，指向了原来的 IMP ,同时为了放在重复 hook ,做了一个判断，如果发现 selector 已经指向了转发 IMP ,那就就不需要进行交换了，代码如下</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123;&#10;     ...&#10;     Method targetMethod = class_getInstanceMethod(klass, selector);&#10;     IMP targetMethodIMP = method_getImplementation(targetMethod);&#10;     if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;&#10;     ...&#10;     SEL aliasSelector = aspect_aliasForSelector(selector);//generator aliasSelector&#10;     if (![klass instancesRespondToSelector:aliasSelector]) &#123;&#10;          __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); &#10;     &#125;&#10;     class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);// point to   _objc_msgForward&#10;   ...&#10;     &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3>3.2.3 handle ForwardInvocation</h3>
<p>基于上面的代码分析知道，转发最终的逻辑代码最终转入 <code>__ASPECTS_ARE_BEING_CALLED__</code> 函数的处理中。这里，需要处理的部分包括额外处理代码（如打点代码）以及最终重新转会原来的 selector 所指向的函数，其实现代码如下：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123;&#10;...&#10;     // Before hooks.  &#21407;&#26469;&#36923;&#36753;&#20043;&#21069;&#25191;&#34892;&#10;    aspect_invoke(classContainer.beforeAspects, info);&#10;    aspect_invoke(objectContainer.beforeAspects, info);&#10;    // Instead hooks.&#10;    BOOL respondsToAlias = YES;&#10;    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;//&#26159;&#21542;&#38656;&#35201;&#26367;&#25442;&#25481;&#21407;&#26469;&#30340;&#36335;&#22522;&#10;         aspect_invoke(classContainer.insteadAspects, info);&#10;         aspect_invoke(objectContainer.insteadAspects, info);&#10;    &#125; else &#123;&#10;        Class klass = object_getClass(invocation.target);&#10;        do &#123;&#10;              if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;&#10;                    [invocation invoke];//&#26681;&#25454;aliasSelector&#25214;&#21040;&#21407;&#26469;&#30340;&#36923;&#36753;&#24182;&#25191;&#34892;&#10;                    break;&#10;                &#125;&#10;            &#125;while (!respondsToAlias &#38;&#38; (klass = class_getSuperclass(klass)));&#10;     &#125;&#10;&#10;    // After hooks.  &#21407;&#26469;&#36923;&#36753;&#20043;&#21518;&#25191;&#34892;&#10;     aspect_invoke(classContainer.afterAspects, info);&#10;     aspect_invoke(objectContainer.afterAspects, info);&#10;&#10;    // If no hooks are installed, call original implementation (usually to throw an exception)&#10;     if (!respondsToAlias) &#123;//&#25214;&#19981;&#21040;aliasSelector&#30340;IMP&#23454;&#29616;&#65292;&#27809;&#26377;&#25214;&#21040;&#21407;&#26469;&#30340;&#36923;&#36753;&#65292;&#36827;&#34892;&#28040;&#24687;&#36716;&#21457;&#10;          invocation.selector = originalSelector;&#10;          SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);&#10;          if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;&#10;               ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);&#10;          &#125; else &#123;&#10;              [self doesNotRecognizeSelector:invocation.selector];&#10;         &#125;&#10;     &#125;                     &#10;...&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>依次处理 before/instead/after hook 以及真正函数实现。如果没有找到原始的函数实现，还需要进行转发操作。</p>
<h1>4. 遇到的问题</h1>
<p>以上就是 Apsects 的实现了，接下来会介绍在实际应用过程中遇到的一些问题以及我的解决方案。</p>
<h2>4.1 JSPatch 兼容问题</h2>
<h3>原因</h3>
<p>我们的项目中引入了 JSPatch 作为我们的 hot fix方案。 JSPatch 也会 hook 住对象的 forwradInvocation 方法，并且 swizzling 相应的 method ，使其指向转发 IMP ,由于 aspects 也是基于这两者实现的，那么会不会导致问题呢(其实类似的问题也会发生在对象提前被 kvo 了，会不会有影响)？</p>
<p>回过头去看3.2.1 我们先是 hook了 类的 <code>forwardInvocation</code> 使其指向了 <code>__ASPECTS_ARE_BEING_CALLED__</code>，然后在 swizzling method 那里，aspect 有做一个判断，如果传入的 selector 指向了转发 IMP ,那么我们什么也不做。因此可想而知，如果传入的 selector 先被 JSPatch hook ,那么，这里我们将不会再处理,也就不会生成 aliasSelector 。</p>
<p>这会导致什么问题了？设想一下，当 selector 被触发的时候，由于 selector 指向了转发 IMP ，因此会进入消息转发过程，同时由于 <code>forwardInvocation</code> 被 aspects 所 hook ,最终会进入到 aspects 的处理逻辑 <code>__ASPECTS_ARE_BEING_CALLED__</code> 中来。让我们回过头去看看3.2.2中的分析，由于找不到 aliasSelector 的 IMP 实现，因此会在此进行消息转发。而在 3.2.2.1 的分析中我们知道，子类并没有实现 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code> ，所以这里的流程就会进入 <code>doesNotRecognizeSelector</code>，从而抛出异常。</p>
<h3>解决方案</h3>
<p>出现上诉问题的原因在于，当 aliasSelector 没有被找到的时候，我们没能将消息正常的转发，也就是没有实现一个 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code> ， 使得消息有机会重新转发回去的方法。因此解决方案也就呼之欲出了，我的做法是在对子类的 <code>forwardInvocation</code> 方法进行交换而不仅仅是替换，实现逻辑如下，强制生成一个 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code> 指向原对象的 <code>forwardInvocation</code> 的实现。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Class aspect_hookClass(NSObject *self, NSError **error) &#123;&#10;    ...&#10;   subclass = objc_allocateClassPair(baseClass, subclassName, 0);&#10;   ...&#10;   IMP originalImplementation = class_replaceMethod(subclass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &#34;v@:@&#34;);&#10;   if (originalImplementation) &#123;&#10;        class_addMethod(subclass, NSSelectorFromString(AspectsForwardInvocationSelectorName),   originalImplementation, &#34;v@:@&#34;);&#10;    &#125; else &#123;&#10;        Method baseTargetMethod = class_getInstanceMethod(baseClass, @selector(forwardInvocation:));&#10;        IMP baseTargetMethodIMP = method_getImplementation(baseTargetMethod);&#10;       if (baseTargetMethodIMP) &#123;&#10;               class_addMethod(subclass, NSSelectorFromString(AspectsForwardInvocationSelectorName), baseTargetMethodIMP, &#34;v@:@&#34;);&#10;         &#125;&#10;  &#125;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意如果 <code>originalImplementation</code> 为空，那么生成的 <code>NSSelectorFromString(AspectsForwardInvocationSelectorName)</code> 将指向 baseClass 也就是真正的这个对象的  forwradInvocation ,这个其实也就是 JSPatch hook 的方法。同时为了保证 block 的执行顺序（也就是前面介绍的 before hooks / instead hooks / after hooks ），这里需要将这段代码提前到 after hooks 执行之前进行。这样就解决了 forwardInvocation 在外面已经被 hook 之后的冲突问题。</p>
<h2>4.2 remove操作</h2>
<h3>4.2.1 单个aspect remove</h3>
<p>单个 aspect 的 remove 貌似有个问题，先来看看源码。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (aspect_isMsgForwardIMP(targetMethodIMP)) &#123;&#10;      SEL aliasSelector = aspect_aliasForSelector(selector);&#10;      Method originalMethod = class_getInstanceMethod(klass, aliasSelector);&#10;      IMP originalIMP = method_getImplementation(originalMethod);&#10;      if (originalIMP) &#123;            &#10;            class_replaceMethod(klass, selector, originalIMP, typeEncoding);&#10;      &#125; &#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你对某个 aspect 执行 remove 操作的时候，它会直接 replace 这个 selector 的 IMP，这个操作是对整个类的所有实例都生效的，这会导致什么问题呢？</p>
<p>以类 A 为例，你先进入了 A 的一个实例 A1 ，hook 住了方法 selector1 ，然后，并没有销毁这个实例的时候，通过其他路径又进入类 A 的另一个实例 A2 ,当然也 hook 了  selector1 ，然后这个时候，如果你 A2 中执行了这个 aspect 的 remove 操作，按照上面的逻辑，类 A 的 selector1 将会恢复正常，可像而知，当你退回 A1 的时候， A1 的 aspect  将会失效。这里其实我的解决思路很简单，因为在执行 remove 操作的时候，其实和这个对象相关的数据结构都已经被清除了，即使不去恢复 selector1 的执行，在进入 <code>__ASPECTS_ARE_BEING_CALLED__</code> 由于这个没有响应的 aspects ,其实会直接跳到原来的处理逻辑，并不会有其他附加影响。</p>
<h3>4.2.2 整个对象aspect remove</h3>
<p>还有一个问题就是，aspects 的 remove 操作只能支持单个的 remove 操作,不支持一次性删除一个对象的所有 aspects 。这里，也做了一个扩展，对原来的 aspects 进行扩展，实现了一次性 remove 一个对象所有 aspects 的方法。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.png"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分類</span>
              
            </div>
          

          

        </nav>

        
        <div class="links">
          <h4>开源项目</h4>
          <div class="links-of-author motion-element">
            
              
                <div class="links-of-author-item">
                  <a href="https://github.com/bang590/JSPatch" target="_blank">
                    
                      <i class="fa fa-github"></i> JSPatch
                    
                  </a>
                </div>
              
                <div class="links-of-author-item">
                  <a href="https://github.com/Zepo/MLeaksFinder" target="_blank">
                    
                      <i class="fa fa-github"></i> MLeaksFinder
                    
                  </a>
                </div>
              
                <div class="links-of-author-item">
                  <a href="https://github.com/hypoyao/GYHttpMock" target="_blank">
                    
                      <i class="fa fa-github"></i> GYHttpMock
                    
                  </a>
                </div>
              
                <div class="links-of-author-item">
                  <a href="https://github.com/liuslevis/GYBootingProtection" target="_blank">
                    
                      <i class="fa fa-github"></i> GYBootingProtection
                    
                  </a>
                </div>
              
            
          </div>
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="footer-links">
  <a href="http://weread.qq.com/">
    微信读书
  </a>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1895639-12', 'auto');
  ga('send', 'pageview');

</script>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'wereadteam';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  

  
  


</body>
</html>
